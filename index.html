<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>木材 なんちゃってCAE（中学生向け）</title>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    :root{
      --bg:#0b1020; --panel:#111a33; --card:#162146;
      --text:#e9eefc; --muted:#aab6dd;
      --bad:#ff4d4d; --good:#4dffb5; --accent:#7aa2ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      background: radial-gradient(1200px 600px at 20% 10%, #18224a 0%, var(--bg) 60%);
      color:var(--text);
    }
    header{
      padding:14px 16px;
      display:flex; align-items:center; gap:10px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      background: rgba(10,14,30,0.6);
      backdrop-filter: blur(10px);
      position:sticky; top:0; z-index:10;
    }
    header .badge{
      padding:4px 10px;
      border:1px solid rgba(255,255,255,0.15);
      border-radius:999px;
      font-size:12px; color:var(--muted);
    }
    header h1{ margin:0; font-size:16px; font-weight:700; letter-spacing:0.2px; }

    .wrap{
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:14px;
      padding:14px;
      height: calc(100vh - 54px);
    }
    .panel{
      background: linear-gradient(180deg, rgba(17,26,51,0.95), rgba(10,14,30,0.95));
      border:1px solid rgba(255,255,255,0.10);
      border-radius:18px;
      padding:12px;
      overflow:auto;
    }
    .panel h2{ margin:10px 8px 8px; font-size:14px; color:#dbe3ff; }
    .note{
      font-size:12px; color:rgba(233,238,252,0.72);
      margin:6px 8px 10px; line-height:1.45;
    }
    .card{
      background: rgba(22,33,70,0.75);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:16px;
      padding:10px;
      margin:8px 6px;
    }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type="number"], select, input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(10,14,30,0.55);
      color:var(--text);
      outline:none;
    }
    input[type="range"]{ width:100%; }
    .hint{ font-size:12px; color:rgba(233,238,252,0.75); line-height:1.35; margin-top:6px; }
    .btns{ display:flex; gap:10px; margin:10px 6px 6px; }
    button{
      flex:1;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(122,162,255,0.18);
      color:var(--text);
      font-weight:700;
      cursor:pointer;
    }
    button:hover{ background: rgba(122,162,255,0.28); }
    button.secondary{ background: rgba(255,255,255,0.08); }

    .result{
      margin:8px 6px;
      padding:12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(10,14,30,0.55);
    }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px;
      font-size:13px;
      margin:4px 0;
    }
    .kv .k{ color:var(--muted); }
    .pill{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
    }
    .pill.good{ border-color: rgba(77,255,181,0.35); color: var(--good); }
    .pill.bad{ border-color: rgba(255,77,77,0.45); color: var(--bad); }
    .pill.info{ border-color: rgba(122,162,255,0.35); color: var(--accent); }

    .view{
      position:relative;
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.10);
      background: #070b16;
      height: 100%;
      min-height: 60vh;
    }
    #canvas{ width:100%; height:100%; display:block; }
    .legend{
      position:absolute; left:12px; bottom:12px;
      background: rgba(10,14,30,0.72);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:14px;
      padding:10px 10px;
      min-width: 260px;
      backdrop-filter: blur(10px);
    }
    .legend .bar{
      height:12px;
      border-radius:999px;
      background: linear-gradient(90deg, #2b5bff 0%, #ff2b2b 100%);
      border:1px solid rgba(255,255,255,0.12);
      margin:6px 0 4px;
    }
    .legend .small{
      display:flex; justify-content:space-between;
      font-size:11px; color:rgba(233,238,252,0.78);
    }
    .toast{
      position:absolute; top:12px; left:12px;
      background: rgba(10,14,30,0.72);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:14px;
      padding:10px 12px;
      max-width: 780px;
      font-size:12px;
      color:rgba(233,238,252,0.88);
      backdrop-filter: blur(10px);
      z-index: 5;
      line-height:1.45;
    }
    hr.sep{ border:none; border-top:1px solid rgba(255,255,255,0.08); margin:10px 0; }

    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; height:auto; }
      .view{ height: 60vh; }
    }
  </style>
</head>
<body>
  <header>
    <span class="badge">木材専用</span>
    <h1>なんちゃってCAE：STLを読み込んで「赤⇄青」で負荷を見える化</h1>
    <span class="badge">梁の曲げ（近似）</span>
  </header>

  <div class="wrap">
    <aside class="panel">
      <div class="note">
        ✅ <b>L=最長辺</b>、<b>h=最短辺（厚み）</b>、<b>b=残り</b>で断面近似（10mm板が想定通り動く）<br/>
        ✅ 色＝<b>σ(x)</b>（位置xだけで決める）→ STLが角しかなくても「全部青/全部赤」になりにくい<br/>
        ✅ 数値は全角でもOK（自動変換）<br/>
        ✅ 下の「デバッグ」に計算値を表示（原因が画面だけで分かる）
      </div>

      <h2>① STLを読み込む</h2>
      <div class="card">
        <label>STLファイル</label>
        <input id="stlFile" type="file" accept=".stl" />
        <div class="row" style="margin-top:10px;">
          <div>
            <label>STLの単位</label>
            <select id="unit">
              <option value="0.001" selected>mm（よくある）→ m</option>
              <option value="0.01">cm → m</option>
              <option value="1">m → m</option>
            </select>
          </div>
          <div>
            <label>梁の軸（長い方向）</label>
            <select id="axis">
              <option value="auto" selected>自動（最長辺）</option>
              <option value="x">X</option>
              <option value="y">Y</option>
              <option value="z">Z</option>
            </select>
          </div>
        </div>
      </div>

      <h2>② 材料（木材）</h2>
      <div class="card">
        <div class="row">
          <div>
            <label>曲げの許容応力（MPa）</label>
            <input id="allowBendMPa" type="text" value="20" />
          </div>
          <div>
            <label>表示用：ヤング率E（GPa）</label>
            <input id="E_GPa" type="text" value="10" />
          </div>
        </div>
      </div>

      <h2>③ 荷重（重さ）</h2>
      <div class="card">
        <label>荷重の種類</label>
        <select id="loadType">
          <option value="point" selected>一点にのせる（点荷重）</option>
          <option value="udl">全体にのせる（等分布荷重）</option>
        </select>
        <div class="row" style="margin-top:10px;">
          <div>
            <label id="loadMagLabel">重さ P（N）</label>
            <input id="loadMag" type="text" value="200" />
          </div>
          <div id="loadPosWrap">
            <label>位置（左→右）</label>
            <!-- 端はM=0になりやすいので最初から避ける -->
            <input id="loadPos" type="range" min="1" max="99" value="50" />
            <div class="hint"><span id="loadPosTxt">50</span>%</div>
          </div>
        </div>
        <div class="hint">※ 両端支持（単純支持）モデル。端に荷重を置くと青になりやすいです。</div>
      </div>

      <h2>④ 接合部（釘）の破壊判定（左右）</h2>
      <div class="card">
        <div class="row">
          <div>
            <label>左の接合位置（左→右）</label>
            <input id="jointPosL" type="range" min="0" max="100" value="10" />
            <div class="hint"><span id="jointPosLTxt">10</span>%</div>
          </div>
          <div>
            <label>左：釘の本数</label>
            <input id="nNailsL" type="text" value="2" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label>右の接合位置（左→右）</label>
            <input id="jointPosR" type="range" min="0" max="100" value="90" />
            <div class="hint"><span id="jointPosRTxt">90</span>%</div>
          </div>
          <div>
            <label>右：釘の本数</label>
            <input id="nNailsR" type="text" value="2" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label>釘1本の許容強度（N）</label>
            <input id="allowNailN" type="text" value="80" />
          </div>
          <div>
            <label>判定の考え方</label>
            <input type="text" value="（その位置のせん断力）÷（釘本数） ≤ 許容" readonly />
          </div>
        </div>
      </div>

      <div class="btns">
        <button id="analyzeBtn">解析する</button>
        <button id="resetBtn" class="secondary">リセット</button>
      </div>

      <div class="result" id="resultBox">
        <div class="kv"><div class="k">状態</div><div class="v"><span class="pill">STL未読み込み</span></div></div>
        <div class="kv"><div class="k">梁の長さ L</div><div class="v">—</div></div>
        <div class="kv"><div class="k">断面（b × h）</div><div class="v">—</div></div>
        <div class="kv"><div class="k">最大応力（MPa）</div><div class="v">—</div></div>
        <div class="kv"><div class="k">安全率（許容/最大）</div><div class="v">—</div></div>

        <hr class="sep">

        <div class="kv"><div class="k">左：せん断力 V（N）</div><div class="v">—</div></div>
        <div class="kv"><div class="k">左：釘1本あたり（N）</div><div class="v">—</div></div>
        <div class="kv"><div class="k">左：判定</div><div class="v">—</div></div>

        <div class="kv"><div class="k">右：せん断力 V（N）</div><div class="v">—</div></div>
        <div class="kv"><div class="k">右：釘1本あたり（N）</div><div class="v">—</div></div>
        <div class="kv"><div class="k">右：判定</div><div class="v">—</div></div>

        <div class="kv"><div class="k">接合（総合）</div><div class="v">—</div></div>

        <hr class="sep">

        <div class="kv"><div class="k">デバッグ（max|M|, maxσ）</div><div class="v" id="dbg">—</div></div>
      </div>
    </aside>

    <main class="view">
      <div class="toast">
        操作：回転＝左ドラッグ / 移動＝右ドラッグ（またはShift+左ドラッグ） / ズーム＝ホイール（超マイルド）<br/>
        <span id="live">（起動チェック中…）</span>
      </div>
      <canvas id="canvas"></canvas>
      <div class="legend">
        <div style="font-size:12px;color:rgba(233,238,252,0.85);">色：σ(x)（青→赤）</div>
        <div class="bar"></div>
        <div class="small"><span>小（青）</span><span>大（赤）</span></div>
        <div class="small" style="margin-top:6px;">
          <span>最大応力</span>
          <span id="legendMax">— MPa</span>
        </div>
      </div>
    </main>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { STLLoader } from "three/addons/loaders/STLLoader.js";

    const el = (id)=>document.getElementById(id);

    // 全角→半角も吸収して数値化（NaN防止）
    function num(v, fallback=0){
      const s = String(v ?? "")
        .replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0) - 0xFEE0))
        .replace(/[－−―]/g, "-")
        .replace(/[．。]/g, ".")
        .trim();
      const x = parseFloat(s);
      return Number.isFinite(x) ? x : fallback;
    }

    const stlFile = el("stlFile");
    const unitSel = el("unit");
    const axisSel = el("axis");

    const allowBendMPa = el("allowBendMPa");
    const loadType = el("loadType");
    const loadMag = el("loadMag");
    const loadMagLabel = el("loadMagLabel");
    const loadPos = el("loadPos");
    const loadPosTxt = el("loadPosTxt");
    const loadPosWrap = el("loadPosWrap");

    const jointPosL = el("jointPosL");
    const jointPosLTxt = el("jointPosLTxt");
    const nNailsL = el("nNailsL");

    const jointPosR = el("jointPosR");
    const jointPosRTxt = el("jointPosRTxt");
    const nNailsR = el("nNailsR");

    const allowNailN = el("allowNailN");

    const analyzeBtn = el("analyzeBtn");
    const resetBtn = el("resetBtn");
    const resultBox = el("resultBox");
    const legendMax = el("legendMax");
    const live = el("live");
    const dbg = el("dbg");

    loadPos.addEventListener("input", ()=> loadPosTxt.textContent = loadPos.value);
    jointPosL.addEventListener("input", ()=> jointPosLTxt.textContent = jointPosL.value);
    jointPosR.addEventListener("input", ()=> jointPosRTxt.textContent = jointPosR.value);

    loadType.addEventListener("change", ()=>{
      if(loadType.value==="point"){
        loadMagLabel.textContent = "重さ P（N）";
        loadPosWrap.style.display = "";
      }else{
        loadMagLabel.textContent = "重さ w（N/m）";
        loadPosWrap.style.display = "none";
      }
    });

    const canvas = el("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x070b16, 5, 35);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.001, 2000);
    camera.position.set(3, 2, 4);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enableZoom = false; // ズームは自前

    scene.add(new THREE.HemisphereLight(0xbfd0ff, 0x111122, 1.1));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 5, 2);
    scene.add(dir);

    const grid = new THREE.GridHelper(20, 20, 0x334477, 0x223355);
    grid.position.y = -0.8;
    scene.add(grid);

    let mesh = null;

    function resize(){
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, rect.width);
      const h = Math.max(1, rect.height);
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);

    function animate(){
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    resize(); animate();
    live.textContent = "（起動OK）";

    // 超マイルドズーム（さらに弱く）
    canvas.addEventListener("wheel", (e)=>{
      e.preventDefault();
      const dy = Math.max(-60, Math.min(60, e.deltaY)); // clamp強め
      const k = 0.00012; // ←かなり弱い
      const scale = Math.exp(dy * k);

      const v = new THREE.Vector3().subVectors(camera.position, controls.target);
      let d = v.length();
      d *= scale;

      const minD = (typeof controls.minDistance === "number") ? controls.minDistance : 0.05;
      const maxD = (typeof controls.maxDistance === "number") ? controls.maxDistance : 1000;
      d = Math.max(minD, Math.min(maxD, d));

      v.normalize().multiplyScalar(d);
      camera.position.copy(controls.target).add(v);
      controls.update();
    }, { passive:false });

    function setStatusPill(text, cls=""){
      const pill = resultBox.querySelector(".pill");
      pill.textContent = text;
      pill.className = "pill" + (cls ? " " + cls : "");
    }
    function setKV(index, valueText){
      const rows = resultBox.querySelectorAll(".kv");
      if(rows[index]){
        rows[index].querySelector(".v").innerHTML = valueText;
      }
    }
    function nice(n, digits=3){
      if(!isFinite(n)) return "—";
      const p = Math.pow(10, digits);
      return (Math.round(n*p)/p).toString();
    }
    function clamp01(x){
      if(!Number.isFinite(x)) return 0;
      return Math.max(0, Math.min(1, x));
    }

    function chooseBeamAxis(size){
      // auto: 最長辺
      const abs = {x:size.x, y:size.y, z:size.z};
      let axis="x";
      if(abs.y>=abs.x && abs.y>=abs.z) axis="y";
      if(abs.z>=abs.x && abs.z>=abs.y) axis="z";
      return axis;
    }

    function centerAndFit(){
      if(!mesh) return;
      mesh.geometry.computeBoundingBox();
      const bbox = mesh.geometry.boundingBox;
      const size = new THREE.Vector3(); bbox.getSize(size);
      const center = new THREE.Vector3(); bbox.getCenter(center);

      mesh.position.sub(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim * 1.6 + 1;

      camera.near = Math.max(0.001, maxDim / 1000);
      camera.far  = maxDim * 200;
      camera.updateProjectionMatrix();

      camera.position.set(dist, dist*0.65, dist);
      controls.target.set(0,0,0);

      controls.minDistance = Math.max(0.05, maxDim * 0.35);
      controls.maxDistance = maxDim * 30;

      controls.update();
    }

    // 両端支持の梁
    function beamForces(L, load){
      if(load.type==="point"){
        const P = load.P;
        const a = load.a;
        const R1 = P*(L-a)/L;
        const V = (x)=> (x < a ? R1 : R1 - P);
        const M = (x)=> (x < a ? R1*x : R1*x - P*(x-a));
        return { M, V };
      }else{
        const w = load.w;
        const R1 = w*L/2;
        const V = (x)=> (R1 - w*x);
        const M = (x)=> (R1*x - w*x*x/2);
        return { M, V };
      }
    }

    function updateVertexColorsFromScalar(geometry, scalarArr, maxScalar){
      const n = scalarArr.length;
      const colors = new Float32Array(n*3);
      const denom = (maxScalar > 0 && Number.isFinite(maxScalar)) ? maxScalar : 1;

      for(let i=0;i<n;i++){
        const t = clamp01(scalarArr[i]/denom);
        colors[i*3+0] = t;
        colors[i*3+1] = 0.0;
        colors[i*3+2] = 1.0 - t;
      }
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      geometry.attributes.color.needsUpdate = true;
    }

    function ensureVertexColorMaterial(){
      if(!mesh) return;
      mesh.material = new THREE.MeshStandardMaterial({
        vertexColors: true,
        roughness: 0.75,
        metalness: 0.0
      });
    }

    // STL Load
    const loader = new STLLoader();
    stlFile.addEventListener("change", async (ev)=>{
      const file = ev.target.files?.[0];
      if(!file) return;

      setStatusPill("読み込み中…");
      try{
        const arrayBuffer = await file.arrayBuffer();
        const geom = loader.parse(arrayBuffer);

        if(mesh){
          scene.remove(mesh);
          mesh.geometry.dispose();
        }

        const s = num(unitSel.value, 0.001);
        geom.scale(s, s, s);

        geom.computeVertexNormals();
        geom.computeBoundingBox();
        geom.computeBoundingSphere();

        mesh = new THREE.Mesh(
          geom,
          new THREE.MeshStandardMaterial({ color: 0x9fb2ff, roughness: 0.8, metalness: 0 })
        );
        scene.add(mesh);

        centerAndFit();

        setStatusPill("STL読み込みOK", "good");

        const bbox = mesh.geometry.boundingBox;
        const size = new THREE.Vector3(); bbox.getSize(size);
        const guessed = chooseBeamAxis(size).toUpperCase();
        setKV(1, `${nice(Math.max(size.x,size.y,size.z),3)} m（最長辺：${guessed}）`);
        setKV(2, `${nice(size.x,3)} m × ${nice(size.y,3)} m × ${nice(size.z,3)} m`);
        legendMax.textContent = "— MPa";
        dbg.textContent = "—";
      }catch(e){
        console.error(e);
        setStatusPill("STL読み込み失敗", "bad");
      }
    });

    // Analyze
    analyzeBtn.addEventListener("click", ()=>{
      if(!mesh){
        setStatusPill("STLが必要です", "bad");
        return;
      }

      mesh.geometry.computeBoundingBox();
      const bbox = mesh.geometry.boundingBox;
      const size = new THREE.Vector3(); bbox.getSize(size);

      // 梁軸（長さL）
      let beamAxis = axisSel.value;
      if(beamAxis === "auto") beamAxis = chooseBeamAxis(size);

      // h=最短辺（厚み）, b=残り（中間）
      const dims = [
        {a:"x", v:size.x},
        {a:"y", v:size.y},
        {a:"z", v:size.z},
      ];
      dims.sort((p,q)=>p.v-q.v);
      const h = dims[0].v;                 // 最短（厚み）
      const midAxis = dims[1].a;
      const b = dims[1].v;                 // 中間（幅）
      const longAxis = dims[2].a;
      const L_auto = dims[2].v;            // 最長（長さ）

      const L = {x:size.x, y:size.y, z:size.z}[beamAxis];

      if(L <= 0 || b <= 0 || h <= 0){
        setStatusPill("寸法が不正です", "bad");
        return;
      }

      const I = (b * Math.pow(h,3)) / 12.0;
      if(!Number.isFinite(I) || I <= 1e-18){
        setStatusPill("断面が薄すぎて計算が不安定です", "bad");
        return;
      }

      // 数値（全角でもOK）
      const allowPa = num(allowBendMPa.value, 20) * 1e6;

      const lt = loadType.value;
      let load = null;
      if(lt==="point"){
        const P = num(loadMag.value, 200);
        const a = L * (Number(loadPos.value)/100);
        load = { type:"point", P, a };
      }else{
        const w = num(loadMag.value, 200);
        load = { type:"udl", w };
      }

      const {M, V} = beamForces(L, load);

      // 色：σ(x)=|M(x)|*(h/2)/I を各頂点のx位置で評価（頂点のyに依存しない）
      const pos = mesh.geometry.getAttribute("position");
      const count = pos.count;

      const minA = bbox.min[beamAxis];
      const scalar = new Float32Array(count);

      let maxScalar = 0;
      let maxM = 0;

      for(let i=0;i<count;i++){
        const vx = pos.getX(i), vy = pos.getY(i), vz = pos.getZ(i);
        const vtx = {x:vx, y:vy, z:vz};
        const xLocal = vtx[beamAxis] - minA;

        const m = Math.abs(M(xLocal));
        if(m > maxM) maxM = m;

        const sigma = m * (h/2) / I;  // Pa
        scalar[i] = sigma;
        if(sigma > maxScalar) maxScalar = sigma;
      }

      // 最大応力は長さ方向をサンプルして安定計算
      const N = 300;
      let maxSigma = 0;
      for(let i=0;i<=N;i++){
        const x = (L * i) / N;
        const sigma = Math.abs(M(x)) * (h/2) / I;
        if(sigma > maxSigma) maxSigma = sigma;
      }

      updateVertexColorsFromScalar(mesh.geometry, scalar, maxScalar);
      ensureVertexColorMaterial();

      const maxMPa = maxSigma / 1e6;
      const sf = (maxSigma > 0) ? (allowPa / maxSigma) : Infinity;

      setStatusPill("解析できました", sf >= 1 ? "good" : "bad");
      setKV(1, `${nice(L,3)} m（梁軸：${beamAxis.toUpperCase()} / 最長=${longAxis.toUpperCase()}）`);
      setKV(2, `${nice(b,3)} m × ${nice(h,3)} m（b=中間, h=最短=厚み）`);
      setKV(3, `${nice(maxMPa,3)} MPa`);
      setKV(4, isFinite(sf) ? `${nice(sf,3)}` : "—");
      legendMax.textContent = `${nice(maxMPa,3)} MPa`;

      dbg.textContent = `max|M|=${nice(maxM,3)} N·m / maxσ=${nice(maxMPa,3)} MPa`;

      // 釘判定（左右）
      const allowN = num(allowNailN.value, 80);

      const xjL = L * (Number(jointPosL.value)/100);
      const xjR = L * (Number(jointPosR.value)/100);

      const VjL = Math.abs(V(xjL));
      const VjR = Math.abs(V(xjR));

      const nailsL = Math.max(1, Math.floor(num(nNailsL.value, 2)));
      const nailsR = Math.max(1, Math.floor(num(nNailsR.value, 2)));

      const perL = VjL / nailsL;
      const perR = VjR / nailsR;

      const passL = perL <= allowN;
      const passR = perR <= allowN;
      const passAll = passL && passR;

      setKV(5, `${nice(VjL,3)} N`);
      setKV(6, `${nice(perL,3)} N`);
      setKV(7, passL ? `<span class="pill good">破壊しない（OK）</span>` : `<span class="pill bad">破壊する（NG）</span>`);

      setKV(8, `${nice(VjR,3)} N`);
      setKV(9, `${nice(perR,3)} N`);
      setKV(10, passR ? `<span class="pill good">破壊しない（OK）</span>` : `<span class="pill bad">破壊する（NG）</span>`);

      setKV(11, passAll ? `<span class="pill good">左右ともOK（全体OK）</span>` : `<span class="pill bad">どちらかNG（全体NG）</span>`);
    });

    resetBtn.addEventListener("click", ()=>{
      if(mesh){
        if(mesh.geometry.getAttribute("color")) mesh.geometry.deleteAttribute("color");
        mesh.material = new THREE.MeshStandardMaterial({ color: 0x9fb2ff, roughness: 0.8, metalness: 0 });
      }
      setStatusPill("リセットしました", "info");
      for(let i=1;i<=11;i++) setKV(i, "—");
      legendMax.textContent = "— MPa";
      dbg.textContent = "—";
    });
  </script>
</body>
</html>
