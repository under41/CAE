<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>木材 かんたんCAE（グラデ）</title>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    :root{ --bg:#0b1020; --panel:#111a33; --card:#162146; --text:#e9eefc; --muted:#aab6dd; --bad:#ff4d4d; --good:#4dffb5; --accent:#7aa2ff; }
    *{box-sizing:border-box}
    body{ margin:0; font-family:system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;
      background:radial-gradient(1200px 600px at 20% 10%, #18224a 0%, var(--bg) 60%); color:var(--text); }
    header{ padding:14px 16px; display:flex; align-items:center; gap:10px;
      border-bottom:1px solid rgba(255,255,255,0.08); background: rgba(10,14,30,0.6);
      backdrop-filter: blur(10px); position:sticky; top:0; z-index:10; }
    header .badge{ padding:4px 10px; border:1px solid rgba(255,255,255,0.15); border-radius:999px; font-size:12px; color:var(--muted); }
    header h1{ margin:0; font-size:16px; font-weight:700; letter-spacing:0.2px; }

    .wrap{ display:grid; grid-template-columns: 380px 1fr; gap:14px; padding:14px; height: calc(100vh - 54px); }
    .panel{ background:linear-gradient(180deg, rgba(17,26,51,0.95), rgba(10,14,30,0.95));
      border:1px solid rgba(255,255,255,0.10); border-radius:18px; padding:12px; overflow:auto; }
    .panel h2{ margin:10px 8px 8px; font-size:14px; color:#dbe3ff; }
    .note{ font-size:12px; color:rgba(233,238,252,0.72); margin:6px 8px 10px; line-height:1.45; }
    .card{ background:rgba(22,33,70,0.75); border:1px solid rgba(255,255,255,0.08); border-radius:16px; padding:10px; margin:8px 6px; }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type="text"], select{ width:100%; padding:10px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.12);
      background:rgba(10,14,30,0.55); color:var(--text); outline:none; }
    input[type="range"]{ width:100%; }
    .hint{ font-size:12px; color:rgba(233,238,252,0.75); line-height:1.35; margin-top:6px; }

    .btns{ display:flex; gap:10px; margin:10px 6px 6px; }
    button{ flex:1; padding:12px; border-radius:14px; border:1px solid rgba(255,255,255,0.12);
      background:rgba(122,162,255,0.18); color:var(--text); font-weight:700; cursor:pointer; }
    button:hover{ background: rgba(122,162,255,0.28); }
    button.secondary{ background: rgba(255,255,255,0.08); }

    .result{ margin:8px 6px; padding:12px; border-radius:16px; border:1px solid rgba(255,255,255,0.10); background:rgba(10,14,30,0.55); }
    .kv{ display:grid; grid-template-columns: 1fr auto; gap:8px; font-size:13px; margin:4px 0; }
    .kv .k{ color:var(--muted); }
    .pill{ display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.06); }
    .pill.good{ border-color: rgba(77,255,181,0.35); color: var(--good); }
    .pill.bad{ border-color: rgba(255,77,77,0.45); color: var(--bad); }
    .pill.info{ border-color: rgba(122,162,255,0.35); color: var(--accent); }

    .view{ position:relative; border-radius:18px; overflow:hidden; border:1px solid rgba(255,255,255,0.10); background:#070b16; height:100%; min-height:60vh; }
    #canvas{ width:100%; height:100%; display:block; }
    .legend{ position:absolute; left:12px; bottom:12px; background: rgba(10,14,30,0.72); border:1px solid rgba(255,255,255,0.10);
      border-radius:14px; padding:10px; min-width:260px; backdrop-filter: blur(10px); }
    .legend .bar{ height:12px; border-radius:999px; background: linear-gradient(90deg, #2b5bff 0%, #ff2b2b 100%);
      border:1px solid rgba(255,255,255,0.12); margin:6px 0 4px; }
    .legend .small{ display:flex; justify-content:space-between; font-size:11px; color:rgba(233,238,252,0.78); }
    .toast{ position:absolute; top:12px; left:12px; background: rgba(10,14,30,0.72); border:1px solid rgba(255,255,255,0.10);
      border-radius:14px; padding:10px 12px; max-width:780px; font-size:12px; color:rgba(233,238,252,0.88);
      backdrop-filter: blur(10px); z-index:5; line-height:1.45; }

    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; height:auto; }
      .view{ height: 60vh; }
    }
  </style>
</head>
<body>
  <header>
    <span class="badge">木材</span>
    <h1>かんたんCAE：赤⇄青で“危ない場所”を直感表示（釘なし）</h1>
    <span class="badge">色＝σ/許容（体感できる版）</span>
  </header>

  <div class="wrap">
    <aside class="panel">
      <div class="note">
        STLを読み込んで「解析する」を押すだけ。<br/>
        ✅ 色は <b>σ/許容応力</b>（危険度）なので、荷重を軽くすれば青く寄ります。
      </div>

      <h2>① STLを読み込む</h2>
      <div class="card">
        <label>STLファイル</label>
        <input id="stlFile" type="file" accept=".stl" />
        <div class="row" style="margin-top:10px;">
          <div>
            <label>STLの単位</label>
            <select id="unit">
              <option value="0.001" selected>mm → m</option>
              <option value="0.01">cm → m</option>
              <option value="1">m → m</option>
            </select>
          </div>
          <div>
            <label>梁の軸（長さ方向）</label>
            <select id="axis">
              <option value="auto" selected>自動（最長辺）</option>
              <option value="x">X</option>
              <option value="y">Y</option>
              <option value="z">Z</option>
            </select>
          </div>
        </div>
      </div>

      <h2>② 荷重</h2>
      <div class="card">
        <label>荷重の種類</label>
        <select id="loadType">
          <option value="point" selected>一点にのせる（点荷重）</option>
          <option value="udl">全体にのせる（等分布荷重）</option>
        </select>

        <div class="row" style="margin-top:10px;">
          <div>
            <label id="loadMagLabel">重さ P（N）</label>
            <input id="loadMag" type="text" value="200" />
          </div>
          <div id="loadPosWrap">
            <label>位置（左→右）</label>
            <input id="loadPos" type="range" min="1" max="99" value="50" />
            <div class="hint"><span id="loadPosTxt">50</span>%</div>
          </div>
        </div>
      </div>

      <h2>③ 強度（基準）</h2>
      <div class="card">
        <label>許容応力（MPa）</label>
        <input id="allowMPa" type="text" value="20" />
      </div>

      <div class="btns">
        <button id="analyzeBtn">解析する</button>
        <button id="resetBtn" class="secondary">リセット</button>
      </div>

      <div class="result">
        <div class="kv"><div class="k">状態</div><div class="v"><span class="pill info" id="statusPill">STL未読み込み</span></div></div>
        <div class="kv"><div class="k">L（長さ）</div><div class="v" id="outL">—</div></div>
        <div class="kv"><div class="k">b×h（幅×厚み）</div><div class="v" id="outBH">—</div></div>
        <div class="kv"><div class="k">最大応力</div><div class="v" id="outMax">—</div></div>
        <div class="kv"><div class="k">安全率（許容/最大）</div><div class="v" id="outSF">—</div></div>
        <div class="kv"><div class="k">デバッグ</div><div class="v" id="outDbg">—</div></div>
      </div>
    </aside>

    <main class="view">
      <div class="toast">
        操作：回転＝左ドラッグ / 移動＝右ドラッグ（またはShift+左ドラッグ） / ズーム＝ホイール（超マイルド）
      </div>
      <canvas id="canvas"></canvas>
      <div class="legend">
        <div style="font-size:12px;color:rgba(233,238,252,0.85);">色：危険度（σ/許容）</div>
        <div class="bar"></div>
        <div class="small"><span>安全（青）</span><span>危険（赤）</span></div>
        <div class="small" style="margin-top:6px;">
          <span id="legendMin">許容= — MPa</span>
          <span id="legendMax">最大= — MPa</span>
        </div>
      </div>
    </main>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { STLLoader } from "three/addons/loaders/STLLoader.js";

    const el = (id)=>document.getElementById(id);

    function num(v, fallback=0){
      const s = String(v ?? "")
        .replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0) - 0xFEE0))
        .replace(/[－−―]/g, "-")
        .replace(/[．。]/g, ".")
        .trim();
      const x = parseFloat(s);
      return Number.isFinite(x) ? x : fallback;
    }
    function nice(n, digits=3){
      if(!isFinite(n)) return "—";
      const p = Math.pow(10, digits);
      return (Math.round(n*p)/p).toString();
    }

    const stlFile = el("stlFile");
    const unitSel = el("unit");
    const axisSel = el("axis");

    const loadType = el("loadType");
    const loadMag = el("loadMag");
    const loadMagLabel = el("loadMagLabel");
    const loadPos = el("loadPos");
    const loadPosTxt = el("loadPosTxt");
    const loadPosWrap = el("loadPosWrap");

    const allowMPa = el("allowMPa");

    const analyzeBtn = el("analyzeBtn");
    const resetBtn = el("resetBtn");

    const statusPill = el("statusPill");
    const outL = el("outL");
    const outBH = el("outBH");
    const outMax = el("outMax");
    const outSF = el("outSF");
    const outDbg = el("outDbg");
    const legendMin = el("legendMin");
    const legendMax = el("legendMax");

    loadPos.addEventListener("input", ()=> loadPosTxt.textContent = loadPos.value);
    loadType.addEventListener("change", ()=>{
      if(loadType.value==="point"){
        loadMagLabel.textContent = "重さ P（N）";
        loadPosWrap.style.display = "";
      }else{
        loadMagLabel.textContent = "重さ w（N/m）";
        loadPosWrap.style.display = "none";
      }
    });

    function setStatus(text, kind="info"){
      statusPill.textContent = text;
      statusPill.className = "pill " + kind;
    }

    // THREE
    const canvas = el("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x070b16, 5, 35);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.001, 2000);
    camera.position.set(3, 2, 4);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enableZoom = false;

    scene.add(new THREE.HemisphereLight(0xbfd0ff, 0x111122, 1.1));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 5, 2);
    scene.add(dir);

    const grid = new THREE.GridHelper(20, 20, 0x334477, 0x223355);
    grid.position.y = -0.8;
    scene.add(grid);

    let mesh = null;
    let heatMat = null;

    function resize(){
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, rect.width);
      const h = Math.max(1, rect.height);
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);

    function animate(){
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    resize(); animate();

    // 超マイルドズーム
    canvas.addEventListener("wheel", (e)=>{
      e.preventDefault();
      const dy = Math.max(-60, Math.min(60, e.deltaY));
      const k = 0.00012;
      const scale = Math.exp(dy * k);

      const v = new THREE.Vector3().subVectors(camera.position, controls.target);
      let d = v.length();
      d *= scale;

      const minD = (typeof controls.minDistance === "number") ? controls.minDistance : 0.05;
      const maxD = (typeof controls.maxDistance === "number") ? controls.maxDistance : 1000;
      d = Math.max(minD, Math.min(maxD, d));

      v.normalize().multiplyScalar(d);
      camera.position.copy(controls.target).add(v);
      controls.update();
    }, { passive:false });

    function centerAndFit(){
      if(!mesh) return;
      mesh.geometry.computeBoundingBox();
      const bbox = mesh.geometry.boundingBox;
      const size = new THREE.Vector3(); bbox.getSize(size);
      const center = new THREE.Vector3(); bbox.getCenter(center);

      mesh.position.sub(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim * 1.6 + 1;

      camera.near = Math.max(0.001, maxDim / 1000);
      camera.far  = maxDim * 200;
      camera.updateProjectionMatrix();

      camera.position.set(dist, dist*0.65, dist);
      controls.target.set(0,0,0);

      controls.minDistance = Math.max(0.05, maxDim * 0.35);
      controls.maxDistance = maxDim * 30;

      controls.update();
    }

    function chooseAxisAuto(size){
      const abs = {x:size.x, y:size.y, z:size.z};
      let a="x";
      if(abs.y>=abs.x && abs.y>=abs.z) a="y";
      if(abs.z>=abs.x && abs.z>=abs.y) a="z";
      return a;
    }

    function makeHeatMaterial(){
      const mat = new THREE.MeshStandardMaterial({ roughness:0.75, metalness:0.0 });

      mat.userData.params = {
        show: 0,
        axis: 0,
        minA: 0,
        L: 1,
        h: 0.01,
        I: 1e-9,
        loadType: 0, // 0 point, 1 udl
        P: 200,
        a: 0.5,
        w: 200,
        sigmaMax: 1.0,      // 表示用（最大応力）
        allowPa: 20e6,      // ★追加：許容応力（Pa）
        baseColor: new THREE.Color(0x9fb2ff),
      };

      mat.onBeforeCompile = (shader) => {
        const p = mat.userData.params;

        shader.uniforms.uShow     = { value: p.show };
        shader.uniforms.uAxis     = { value: p.axis };
        shader.uniforms.uMinA     = { value: p.minA };
        shader.uniforms.uL        = { value: p.L };
        shader.uniforms.uH        = { value: p.h };
        shader.uniforms.uI        = { value: p.I };
        shader.uniforms.uLoadType = { value: p.loadType };
        shader.uniforms.uP        = { value: p.P };
        shader.uniforms.ua        = { value: p.a };
        shader.uniforms.uw        = { value: p.w };
        shader.uniforms.uSigmaMax = { value: p.sigmaMax };
        shader.uniforms.uAllowPa  = { value: p.allowPa }; // ★追加
        shader.uniforms.uBase     = { value: p.baseColor.clone() };

        mat.userData.shader = shader;

        shader.vertexShader = shader.vertexShader
          .replace(`#include <common>`, `#include <common>\nvarying vec3 vPos;`)
          .replace(`#include <begin_vertex>`, `#include <begin_vertex>\nvPos = position;`);

        shader.fragmentShader = shader.fragmentShader
          .replace(`#include <common>`, `#include <common>
            varying vec3 vPos;
            uniform int uShow;
            uniform int uAxis;
            uniform float uMinA;
            uniform float uL;
            uniform float uH;
            uniform float uI;
            uniform int uLoadType;
            uniform float uP;
            uniform float ua;
            uniform float uw;
            uniform float uSigmaMax;
            uniform float uAllowPa;   // ★追加
            uniform vec3 uBase;

            float getX(vec3 p){
              return (uAxis==0) ? p.x : (uAxis==1 ? p.y : p.z);
            }
            float moment(float x){
              if(uLoadType==0){
                float P = uP;
                float a = ua;
                float L = uL;
                float R1 = P*(L-a)/L;
                return (x < a) ? (R1*x) : (R1*x - P*(x-a));
              }else{
                float w = uw;
                float L = uL;
                float R1 = w*L*0.5;
                return (R1*x - w*x*x*0.5);
              }
            }
          `)
          .replace(
            `#include <color_fragment>`,
            `
              if(uShow==0){
                diffuseColor.rgb = uBase;
              }else{
                float xLocal = clamp(getX(vPos) - uMinA, 0.0, uL);
                float M = abs(moment(xLocal));
                float sigma = M * (uH*0.5) / max(uI, 1e-18); // Pa

                // ★ここが本命：色は「σ/許容」で決める（Pを軽くすると青くなる）
                float t = clamp(sigma / max(uAllowPa, 1e-6), 0.0, 1.0);
                vec3 heat = vec3(t, 0.0, 1.0 - t); // 青→赤
                diffuseColor.rgb = heat;
              }
            `
          );
      };

      return mat;
    }

    function applyParamsToUniforms(){
      if(!heatMat || !heatMat.userData.shader) return;
      const u = heatMat.userData.shader.uniforms;
      const p = heatMat.userData.params;
      u.uShow.value     = p.show;
      u.uAxis.value     = p.axis;
      u.uMinA.value     = p.minA;
      u.uL.value        = p.L;
      u.uH.value        = p.h;
      u.uI.value        = p.I;
      u.uLoadType.value = p.loadType;
      u.uP.value        = p.P;
      u.ua.value        = p.a;
      u.uw.value        = p.w;
      u.uSigmaMax.value = p.sigmaMax;
      u.uAllowPa.value  = p.allowPa;     // ★追加
      u.uBase.value.copy(p.baseColor);
    }

    const loader = new STLLoader();
    stlFile.addEventListener("change", async (ev)=>{
      const file = ev.target.files?.[0];
      if(!file) return;

      setStatus("読み込み中…","info");
      try{
        const arrayBuffer = await file.arrayBuffer();
        const geom = loader.parse(arrayBuffer);

        if(mesh){
          scene.remove(mesh);
          mesh.geometry.dispose();
        }

        const s = num(unitSel.value, 0.001);
        geom.scale(s, s, s);

        geom.computeVertexNormals();
        geom.computeBoundingBox();
        geom.computeBoundingSphere();

        heatMat = makeHeatMaterial();
        mesh = new THREE.Mesh(geom, heatMat);
        scene.add(mesh);

        centerAndFit();
        setStatus("STL読み込みOK","good");

        heatMat.userData.params.show = 0;
        requestAnimationFrame(() => applyParamsToUniforms());

        outL.textContent = outBH.textContent = outMax.textContent = outSF.textContent = outDbg.textContent = "—";
        legendMin.textContent = "許容= — MPa";
        legendMax.textContent = "最大= — MPa";
      }catch(e){
        console.error(e);
        setStatus("STL読み込み失敗","bad");
      }
    });

    analyzeBtn.addEventListener("click", ()=>{
      if(!mesh || !heatMat){
        setStatus("STLが必要です","bad");
        return;
      }

      mesh.geometry.computeBoundingBox();
      const bbox = mesh.geometry.boundingBox;
      const size = new THREE.Vector3(); bbox.getSize(size);

      let axisSelVal = axisSel.value;
      if(axisSelVal === "auto") axisSelVal = chooseAxisAuto(size);
      const axisIndex = (axisSelVal === "x") ? 0 : (axisSelVal === "y" ? 1 : 2);

      const L = {x:size.x, y:size.y, z:size.z}[axisSelVal];
      const dims = [{v:size.x},{v:size.y},{v:size.z}].sort((a,b)=>a.v-b.v);
      const h = dims[0].v;
      const b = dims[1].v;
      const I = (b * Math.pow(h,3))/12.0;

      const lt = loadType.value;
      let P=0,w=0,a=0;
      if(lt==="point"){
        P = Math.max(1e-9, num(loadMag.value, 200));
        a = L * (Number(loadPos.value)/100);
        a = Math.max(L*0.05, Math.min(L*0.95, a));
      }else{
        w = Math.max(1e-9, num(loadMag.value, 200));
      }

      const maxM = (lt==="point") ? (P * a * (L-a) / L) : (w * L * L / 8.0);
      const sigmaMax = Math.max(1e-12, Math.abs(maxM) * (h*0.5) / Math.max(I, 1e-18)); // Pa

      // ★許容応力（Pa）をparamsへ（色に効く）
      const allow = num(allowMPa.value, 20);     // MPa
      const allowPa = allow * 1e6;

      const p = heatMat.userData.params;
      p.show = 1;
      p.axis = axisIndex;
      p.minA = bbox.min[axisSelVal];
      p.L = L;
      p.h = h;
      p.I = I;
      p.loadType = (lt==="point") ? 0 : 1;
      p.P = P;
      p.a = a;
      p.w = w;
      p.sigmaMax = sigmaMax;    // 表示用
      p.allowPa = allowPa;      // ★色の基準
      applyParamsToUniforms();

      const maxMPa = sigmaMax / 1e6;
      const sf = (maxMPa > 0) ? (allow / maxMPa) : Infinity;

      outL.textContent = `${nice(L,3)} m（軸:${axisSelVal.toUpperCase()}）`;
      outBH.textContent = `${nice(b,3)} m × ${nice(h,3)} m`;
      outMax.textContent = `${nice(maxMPa,3)} MPa`;
      outSF.textContent = isFinite(sf) ? nice(sf,3) : "—";
      legendMin.textContent = `許容= ${nice(allow,3)} MPa`;
      legendMax.textContent = `最大= ${nice(maxMPa,3)} MPa`;

      const util = (allow > 0) ? (maxMPa / allow) : Infinity;
      outDbg.textContent = (lt==="point")
        ? `P=${nice(P,3)}N a=${nice(a,3)}m max|M|=${nice(maxM,3)} N·m / 利用率=${nice(util,3)}`
        : `w=${nice(w,3)}N/m max|M|=${nice(maxM,3)} N·m / 利用率=${nice(util,3)}`;

      setStatus("解析できました", sf>=1 ? "good" : "bad");
    });

    resetBtn.addEventListener("click", ()=>{
      if(!heatMat){
        setStatus("リセットしました","info");
        return;
      }
      heatMat.userData.params.show = 0;
      applyParamsToUniforms();

      setStatus("リセットしました","info");
      outL.textContent = outBH.textContent = outMax.textContent = outSF.textContent = outDbg.textContent = "—";
      legendMin.textContent = "許容= — MPa";
      legendMax.textContent = "最大= — MPa";
    });
  </script>
</body>
</html>
