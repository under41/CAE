<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ブックラック強度シミュレーター</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        #ui {
            position: absolute; top: 20px; width: 100%;
            text-align: center; color: white; pointer-events: none;
        }
        .controls {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px;
            color: white; pointer-events: auto;
        }
        #drop-zone {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            color: #777; border: 2px dashed #444; z-index: -1;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h2>強度シミュレーター (教育用)</h2>
        <p id="msg">STLファイルをドロップしてください</p>
    </div>

    <div class="controls">
        <button onclick="resetColors()">負荷をリセット</button>
        <span style="margin-left:15px;">棚板をクリックして本を置く場所を指定してください</span>
    </div>

    <div id="drop-zone">ここにファイルをドロップ</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(200, 200, 200);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(1, 1, 1);
        scene.add(light);

        let mesh = null;
        let originalColors = null;

        // --- ファイル読み込み ---
        window.addEventListener('dragover', (e) => e.preventDefault());
        window.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.stl')) {
                const reader = new FileReader();
                reader.onload = (event) => initModel(event.target.result);
                reader.readAsArrayBuffer(file);
            }
        });

        function initModel(data) {
            if (mesh) scene.remove(mesh);
            const loader = new STLLoader();
            const geometry = loader.parse(data);
            geometry.center();

            // 初期色（全頂点を青に）
            const count = geometry.attributes.position.count;
            const colors = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                colors[i*3] = 0.1; colors[i*3+1] = 0.2; colors[i*3+2] = 0.8;
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            originalColors = colors.slice();

            const material = new THREE.MeshPhongMaterial({ vertexColors: true, side: THREE.DoubleSide });
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            document.getElementById('msg').innerText = "モデル読み込み完了！棚板をクリックして荷重をシミュレート";
        }

        // --- クリックによる強度変化（ヒートマップ） ---
        window.addEventListener('click', (event) => {
            if (!mesh) return;

            // マウス座標を3D空間用に変換
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(mesh);

            if (intersects.length > 0) {
                applyStress(intersects[0].point);
            }
        });

        function applyStress(point) {
            const geometry = mesh.geometry;
            const positions = geometry.attributes.position;
            const colors = geometry.attributes.color;
            const count = positions.count;
            
            const radius = 50; // 負荷が広がる範囲

            for (let i = 0; i < count; i++) {
                const vx = positions.getX(i);
                const vy = positions.getY(i);
                const vz = positions.getZ(i);

                // クリック地点からの距離を計算
                const dist = Math.sqrt((vx-point.x)**2 + (vy-point.y)**2 + (vz-point.z)**2);

                if (dist < radius) {
                    const ratio = 1 - (dist / radius);
                    // 距離が近いほど赤(Hue=0)、遠いほど青(Hue=0.7)
                    const c = new THREE.Color();
                    c.setHSL(0.7 * (1 - ratio), 1.0, 0.5);
                    colors.setXYZ(i, c.r, c.g, c.b);
                }
            }
            colors.needsUpdate = true;
        }

        window.resetColors = function() {
            if (!mesh) return;
            mesh.geometry.attributes.color.array.set(originalColors);
            mesh.geometry.attributes.color.needsUpdate = true;
        };

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
