<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>STL読み込み＋簡易強度（梁近似）</title>
  <style>
    body{font-family:system-ui,-apple-system,"Yu Gothic",sans-serif;margin:16px}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:12px}
    .card{border:1px solid #ddd;border-radius:12px;padding:12px}
    label{font-size:12px;color:#333;display:block;margin:8px 0 4px}
    input,select{width:100%;padding:8px 10px;border:1px solid #ccc;border-radius:10px}
    #view{width:100%;height:420px;border:1px solid #ddd;border-radius:12px;overflow:hidden}
    .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .kpi .box{border:1px solid #eee;border-radius:12px;padding:10px}
    .v{font-weight:800;font-size:18px}
    .small{font-size:12px;color:#555;line-height:1.5}
  </style>

  <!-- three.js（モジュール） -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <h2>STL読み込み → 寸法抽出 → 簡易強度（梁の曲げ近似）</h2>

  <div class="wrap">
    <div class="card">
      <label>STLファイル</label>
      <input id="file" type="file" accept=".stl" />

      <label>近似モデル</label>
      <select id="model">
        <option value="cantilever">片持ち梁（先端集中荷重）</option>
        <option value="simple">単純支持梁（中央集中荷重）</option>
      </select>

      <label>材料（ヤング率 E）</label>
      <select id="mat">
        <option value="10000000000">木材（目安 10 GPa）</option>
        <option value="69000000000">アルミ（69 GPa）</option>
        <option value="200000000000">鋼（200 GPa）</option>
        <option value="custom">手入力</option>
      </select>

      <label>E（GPa）※手入力時</label>
      <input id="E" type="number" step="0.1" value="10" />

      <label>荷重 F（N）</label>
      <input id="F" type="number" step="0.1" value="20" />

      <label class="small">STLから抽出した寸法（mm）</label>
      <div class="kpi">
        <div class="box"><div class="small">L</div><div class="v" id="Lmm">-</div></div>
        <div class="box"><div class="small">b</div><div class="v" id="bmm">-</div></div>
        <div class="box"><div class="small">h</div><div class="v" id="hmm">-</div></div>
        <div class="box"><div class="small">注意</div><div class="small" id="note">-</div></div>
      </div>

      <div class="kpi">
        <div class="box"><div class="small">最大曲げ応力 σmax</div><div class="v" id="sigma">-</div></div>
        <div class="box"><div class="small">最大たわみ δmax</div><div class="v" id="delta">-</div></div>
      </div>

      <p class="small">
        ※これは「STL形状を外接直方体に近似して梁計算」する簡易モデルです。<br>
        形が複雑（穴・リブ・曲面）なほど誤差は増えます。
      </p>
    </div>

    <div class="card">
      <div id="view"></div>
      <p class="small">
        STLはこのページ内で読み込んで表示します（サーバへアップロードする実装にはしていません）。
      </p>
    </div>
  </div>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { STLLoader } from "three/addons/loaders/STLLoader.js";

  const $ = (id) => document.getElementById(id);

  // --- three.js scene ---
  const view = $("view");
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf7f7f7);

  const camera = new THREE.PerspectiveCamera(45, view.clientWidth / view.clientHeight, 0.1, 1000);
  camera.position.set(120, 90, 140);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(view.clientWidth, view.clientHeight);
  view.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(100, 200, 100);
  scene.add(dir);

  const grid = new THREE.GridHelper(200, 20);
  scene.add(grid);

  let mesh = null;
  let dims = null; // {L,b,h} in meters

  function animate(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  // resize
  new ResizeObserver(() => {
    const w = view.clientWidth, h = view.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }).observe(view);

  function syncMatInput(){
    $("E").disabled = $("mat").value !== "custom";
  }

  function fmt(x, unit){ return Number.isFinite(x) ? `${x.toFixed(2)} ${unit}` : "-"; }

  function computeBeam(L, b, h, F, E, model){
    // I = b h^3 / 12, Z = b h^2 / 6
    const I = b * Math.pow(h,3) / 12;
    const Z = b * Math.pow(h,2) / 6;

    let Mmax, delta;
    if (model === "cantilever"){
      Mmax = F * L;
      delta = (F * Math.pow(L,3)) / (3 * E * I);
    } else {
      Mmax = F * L / 4;
      delta = (F * Math.pow(L,3)) / (48 * E * I);
    }
    const sigma = Mmax / Z;
    return { sigma, delta };
  }

  function updateCalc(){
    syncMatInput();
    if (!dims) return;

    const model = $("model").value;
    const mat = $("mat").value;
    const E = (mat === "custom") ? Number($("E").value) * 1e9 : Number(mat); // Pa
    const F = Number($("F").value);

    const {L, b, h} = dims; // meters
    const r = computeBeam(L, b, h, F, E, model);

    $("sigma").textContent = fmt(r.sigma/1e6, "MPa");
    $("delta").textContent = fmt(r.delta*1000, "mm");
  }

  function setDimsFromBoundingBox(geo){
    geo.computeBoundingBox();
    const bb = geo.boundingBox;

    // three.js units are "whatever the STL uses"
    // 多くのSTLはmm想定ですが保証はないので注意表示
    const size = new THREE.Vector3();
    bb.getSize(size);

    // L = 最大辺、残りを b,h とする（単純化）
    const arr = [size.x, size.y, size.z].sort((a,b)=>b-a);
    const Lmm = arr[0], bmm = arr[1], hmm = arr[2];

    $("Lmm").textContent = `${Lmm.toFixed(1)} mm`;
    $("bmm").textContent = `${bmm.toFixed(1)} mm`;
    $("hmm").textContent = `${hmm.toFixed(1)} mm`;

    $("note").textContent = "STLの単位がmm前提（違う場合は寸法がズレます）";

    // meters
    dims = { L: Lmm/1000, b: bmm/1000, h: hmm/1000 };
  }

  function fitCameraToObject(obj){
    const box = new THREE.Box3().setFromObject(obj);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    const maxSize = Math.max(size.x, size.y, size.z);
    const fitDist = maxSize * 1.6;

    camera.position.set(center.x + fitDist, center.y + fitDist*0.6, center.z + fitDist);
    camera.lookAt(center);
    controls.target.copy(center);
    controls.update();
  }

  $("file").addEventListener("change", (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;

    const reader = new FileReader();
    reader.onload = () => {
      const arrayBuffer = reader.result;
      const loader = new STLLoader();
      const geometry = loader.parse(arrayBuffer);

      // 古いメッシュがあれば削除
      if (mesh){
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }

      const material = new THREE.MeshStandardMaterial({ color: 0x6b7280, metalness: 0.05, roughness: 0.8 });
      mesh = new THREE.Mesh(geometry, material);

      // 見やすいように中央へ
      geometry.computeBoundingBox();
      const bb = geometry.boundingBox;
      const center = new THREE.Vector3();
      bb.getCenter(center);
      mesh.position.sub(center);

      scene.add(mesh);

      // 寸法抽出（簡易：外接直方体）
      // positionを引いてもサイズは変わらないのでgeometryのbboxでOK
      setDimsFromBoundingBox(geometry);

      fitCameraToObject(mesh);
      updateCalc();
    };
    reader.readAsArrayBuffer(f);
  });

  ["model","mat","E","F"].forEach(id => $(id).addEventListener("input", updateCalc));
  syncMatInput();
</script>
</body>
</html>
